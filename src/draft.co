assert = require \assert
{EventEmitter} = require \events
Bot = require \./bot
Human = require \./human
db = require \./db
_ = require \./_
genCube = require \./generate/cube
genPack = require \./generate/pack
Sets = require \../data/sets

HOUR = 1e3 * 60 * 60
drafts = {}

do decrement = ->
  for id, d in drafts
    for p of d.players
      if p.time and !--p.time
        p.autopick!
  setTimeout decrement, 1e3

class Draft extends EventEmitter
  ({cube, host, seats, sets, type}) ->
    assert type of <[ cube draft sealed ]>
    assert 1 <= seats <= 8
    assert typeof host is \string
    if sets
      assert sets.length is 3
      for set of sets
        assert set in Sets
    else
      assert typeof cube is \string

    @ <<<< { host, seats, sets, type }
    @ <<<<
      id: _.rand 1e9 .toString 16
      players: []
      startTime: Date.now! / 1e3 | 0
      timeout: setTimeout @~end, HOUR
    if cube
      genCube that, seats * 3, (@cube) ~>
        if @state is \started
          @start!

  delta: -1
  round: 0
  state: \open

  join: (sock) ->
    {id} = sock
    for p of @players
      if p.id is id
        p.attach sock
        p.send @{ round, sets }
        @meta!
        return

    unless @state is \open
      return sock.send \error 'draft started'

    if @players.length is @seats
      return sock.send \error 'draft full'

    h = new Human sock, sock.id is @host
    @add h

  add: (p) ->
    @players.push p
    p.on \pass @~pass

    return if p.isBot

    p.on \meta @~meta
    p.on \drop @~drop

    if p.isHost
      p.once \start (@addBots) ~>
        @state = \started
        unless @type is \cube and !@cube
          @start!

    @meta!

  drop: (p) ->
    return if @round

    index = @players.indexOf p
    @players.splice index, 1
    @meta!

  send: !(name, args) ->
    for p of @players
      p.send name, args

  meta: !->
    # TODO only send time + packs
    players = for p of @players
      { p.dropped, p.hash, p.name, p.time, packs: p.packs.length }
    for p, i of @players
      p.send \set { players, self: i }

  start: ->
    clearTimeout @timeout
    @timeout = setTimeout @~end, HOUR

    if @type is \sealed
      @round = 4
      for p of @players
        main = for @sets => genPack &
        main = _.flat <>
        p.main = main
        p.send \set { main, @round }
      return

    drafts[@id] = @

    if @addBots
      while @players.length < @seats
        @add new Bot

    _.shuffle @players

    for p, i of @players
      p.index = i

    @startRound!

  startRound: !->
    r = ++@round
    @send \set round: r
    if r is 4
      return @end!

    if @sets
      set = that[r - 1]

    @delta *= -1
    @activePacks = @players.length

    for p of @players
      p.startRound!
      p.receive if @cube
        that.pop!
      else
        genPack set

  pass: (pack, index) ->
    player = _.at @players, index + @delta

    if pack.length
      player.receive pack
    else if !--@activePacks
      @startRound!

    # TODO ignore bot, dropped passes
    @meta!

  end: ->
    console.log \end @id

    clearTimeout @timeout
    delete drafts[@id]
    @emit \end

    data = @{ sets, start: startTime }
    data.end = Date.now! / 1e3 | 0
    data.players = for p of @players
      p{ isBot, picks }

    db data

module.exports = Draft
